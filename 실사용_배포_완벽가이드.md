# 실사용 HMI 장비 배포 완벽 가이드

## 목차
1. [HMI 하드웨어 타입별 배포 방법](#hmi-하드웨어-타입별-배포-방법)
2. [현재 시스템(웹 기반 HMI) 배포](#현재-시스템웹-기반-hmi-배포)
3. [프로덕션용 Docker 설정](#프로덕션용-docker-설정)
4. [임베디드 리눅스 HMI 배포](#임베디드-리눅스-hmi-배포)
5. [산업용 패널 PC 배포](#산업용-패널-pc-배포)
6. [원격 업데이트 시스템](#원격-업데이트-시스템)

---

## HMI 하드웨어 타입별 배포 방법

### 1. **산업용 패널 PC (현재 시스템 적합) ⭐**

```
특징:
- Windows 10/11 IoT 또는 Linux
- 터치스크린
- 산업용 환경 (방진, 방수)
- 일반 PC와 동일한 환경

예시:
- Advantech WebOP-3000 시리즈
- Siemens SIMATIC Panel PC
- Delta Electronics DOP-100 시리즈
```

**배포 방법:**
```
방법 1: Docker 배포 (권장)
방법 2: USB 설치
방법 3: 네트워크 배포
```

### 2. **임베디드 리눅스 HMI**

```
특징:
- ARM/x86 CPU
- 경량 Linux (Yocto, Buildroot)
- 제한된 리소스
- 커스텀 펌웨어

예시:
- Raspberry Pi + 터치스크린
- BeagleBone Black
- 커스텀 임베디드 보드
```

**배포 방법:**
```
방법 1: SD 카드 이미지
방법 2: SSH/SCP 업로드
방법 3: OTA(Over-The-Air) 업데이트
```

### 3. **전용 HMI 터미널**

```
특징:
- Siemens, Allen-Bradley, Schneider 등
- 전용 개발 툴 사용
- 폐쇄형 시스템

예시:
- Siemens TP/KTP 시리즈
- Allen-Bradley PanelView
- Schneider Magelis
```

**배포 방법:**
```
제조사 전용 툴 사용:
- Siemens TIA Portal
- Rockwell FactoryTalk
- Schneider Vijeo Designer
```

---

## 현재 시스템(웹 기반 HMI) 배포

### 시스템 구성

```
현재 개발 시스템:
├── Frontend: React + Vite (웹 UI)
├── Backend: FastAPI (Python)
├── Simulator: Modbus TCP (PLC 시뮬레이터)
└── 통신: WebSocket (실시간)

배포 대상:
산업용 패널 PC (Windows/Linux)
```

### 배포 방식 선택 가이드

| 방식 | 적합한 경우 | 장점 | 단점 |
|------|-----------|------|------|
| **Docker** | PC 기반, 네트워크 있음 | 쉬운 배포, 환경 독립 | Docker 설치 필요 |
| **실행파일** | 독립 실행 필요 | Python/Node 불필요 | 용량 큼, 빌드 복잡 |
| **네이티브** | 성능 중요 | 최고 성능 | 설치 복잡 |

---

## 프로덕션용 Docker 설정

### 1. 프로덕션 Dockerfile 생성

#### **backend/Dockerfile.production**
```dockerfile
FROM python:3.10-slim

WORKDIR /app

# 시스템 패키지
RUN apt-get update && apt-get install -y \
    gcc \
    && rm -rf /var/lib/apt/lists/*

# Python 패키지 설치
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# 소스 코드 복사 (프로덕션)
COPY . .

# 포트
EXPOSE 8000

# 환경 변수
ENV PYTHONUNBUFFERED=1
ENV ENVIRONMENT=production

# 프로덕션 실행 (--reload 제거)
CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
```

#### **frontend/Dockerfile.production**
```dockerfile
# 빌드 스테이지
FROM node:18-alpine AS builder

WORKDIR /app

# 의존성 설치
COPY package*.json ./
RUN npm ci --production=false

# 소스 복사 및 빌드
COPY . .
RUN npm run build

# 프로덕션 스테이지 (Nginx)
FROM nginx:alpine

# 빌드된 파일 복사
COPY --from=builder /app/dist /usr/share/nginx/html

# Nginx 설정
COPY nginx.conf /etc/nginx/conf.d/default.conf

# 포트
EXPOSE 80

# 실행
CMD ["nginx", "-g", "daemon off;"]
```

#### **frontend/nginx.conf**
```nginx
server {
    listen 80;
    server_name localhost;

    root /usr/share/nginx/html;
    index index.html;

    # SPA 라우팅 지원
    location / {
        try_files $uri $uri/ /index.html;
    }

    # API 프록시
    location /api/ {
        proxy_pass http://backend:8000/;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
    }

    # WebSocket 프록시
    location /ws {
        proxy_pass http://backend:8000/ws;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
    }

    # 캐싱 설정
    location ~* \.(js|css|png|jpg|jpeg|gif|svg|ico)$ {
        expires 1y;
        add_header Cache-Control "public, immutable";
    }
}
```

### 2. 프로덕션 docker-compose.yml

```yaml
# docker-compose.production.yml
services:
  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile.production
    container_name: hmi-backend-prod
    ports:
      - "8000:8000"
    restart: always
    environment:
      - PYTHONUNBUFFERED=1
      - PLC_HOST=${PLC_HOST:-192.168.1.100}  # 실제 PLC IP
      - PLC_PORT=${PLC_PORT:-502}
      - ENVIRONMENT=production
    volumes:
      - ./data:/app/data  # 데이터만 볼륨
    networks:
      - hmi-network
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile.production
    container_name: hmi-frontend-prod
    ports:
      - "80:80"
    restart: always
    depends_on:
      - backend
    networks:
      - hmi-network
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

networks:
  hmi-network:
    driver: bridge
```

### 3. 환경 변수 설정

**.env.production**
```bash
# PLC 설정
PLC_HOST=192.168.1.100
PLC_PORT=502

# 시스템 설정
ENVIRONMENT=production
LOG_LEVEL=INFO

# 보안 설정
SECRET_KEY=your-secret-key-here
ALLOWED_HOSTS=localhost,192.168.1.50

# 데이터베이스 (필요시)
# DB_HOST=localhost
# DB_PORT=5432
```

---

## 실사용 배포 시나리오

### 시나리오 1: 산업용 패널 PC (Windows)

#### 준비물
```
1. 산업용 패널 PC (Windows 10 IoT)
2. USB 메모리 (16GB)
3. Docker Desktop 설치 파일
4. HMI 프로그램 (배포 버전)
```

#### 배포 절차

**1단계: USB 준비**
```batch
개발 PC에서:

1. PREPARE_USB.bat 실행
2. USB_DEPLOY 폴더에 추가:
   - Docker Desktop Installer.exe
   - 설치_가이드.txt
   - START_HMI_PRODUCTION.bat

USB 구조:
USB:\
├── Docker Desktop Installer.exe
├── 설치_가이드.txt
├── START_HMI_PRODUCTION.bat
└── HMI_REAL\
    ├── docker-compose.production.yml
    ├── .env.production
    └── ...
```

**2단계: 현장 설치**
```batch
패널 PC에서:

1. USB 연결

2. Docker Desktop 설치
   - Docker Desktop Installer.exe 실행
   - 재부팅

3. HMI 프로그램 복사
   - USB:\HMI_REAL → C:\HMI_REAL

4. 환경 설정
   - .env.production 편집
   - PLC_HOST=192.168.1.100 (실제 PLC IP)

5. 실행
   - START_HMI_PRODUCTION.bat 더블클릭
```

**3단계: 자동 시작 설정**
```batch
Windows 시작 프로그램 등록:

1. Win + R → shell:startup

2. START_HMI_PRODUCTION.bat 바로가기 복사

3. PC 재부팅 시 자동 실행
```

### 시나리오 2: 임베디드 리눅스 (라즈베리파이)

#### 준비물
```
1. Raspberry Pi 4 (4GB+)
2. 터치스크린 (7인치)
3. SD 카드 (32GB)
4. Raspberry Pi OS Lite
```

#### 배포 절차

**1단계: OS 설치**
```bash
# Raspberry Pi Imager로 OS 설치
# SSH 활성화
# Wi-Fi/이더넷 설정
```

**2단계: Docker 설치**
```bash
# SSH로 접속
ssh pi@192.168.1.50

# Docker 설치
curl -fsSL https://get.docker.com -o get-docker.sh
sudo sh get-docker.sh

# 사용자 권한 추가
sudo usermod -aG docker pi

# Docker Compose 설치
sudo apt-get update
sudo apt-get install -y docker-compose
```

**3단계: HMI 프로그램 배포**
```bash
# SCP로 파일 전송 (개발 PC에서)
scp -r HMI_REAL pi@192.168.1.50:~/

# 라즈베리파이에서
cd ~/HMI_REAL
docker-compose -f docker-compose.production.yml up -d
```

**4단계: 자동 시작 설정**
```bash
# systemd 서비스 생성
sudo nano /etc/systemd/system/hmi.service

[Unit]
Description=HMI System
After=docker.service
Requires=docker.service

[Service]
Type=oneshot
RemainAfterExit=yes
WorkingDirectory=/home/pi/HMI_REAL
ExecStart=/usr/bin/docker-compose -f docker-compose.production.yml up -d
ExecStop=/usr/bin/docker-compose -f docker-compose.production.yml down
User=pi

[Install]
WantedBy=multi-user.target

# 서비스 활성화
sudo systemctl enable hmi
sudo systemctl start hmi
```

**5단계: 키오스크 모드 (전체화면)**
```bash
# Chromium 자동 시작
sudo apt-get install -y chromium-browser unclutter

# 자동 시작 스크립트
nano ~/.config/autostart/hmi.desktop

[Desktop Entry]
Type=Application
Name=HMI
Exec=chromium-browser --kiosk --incognito http://localhost

# 재부팅
sudo reboot
```

---

## 배포용 스크립트 생성

### START_HMI_PRODUCTION.bat

```batch
@echo off
chcp 65001 >nul
cd /d "%~dp0"

echo ============================================================
echo    ESS HMI 시스템 (프로덕션)
echo ============================================================
echo.

REM 환경 설정 로드
if exist ".env.production" (
    echo [1/4] 환경 설정 로드 중...
    for /f "delims== tokens=1,2" %%a in (.env.production) do (
        set %%a=%%b
    )
    echo     ✓ 완료
) else (
    echo [경고] .env.production 파일이 없습니다.
    echo        기본 설정을 사용합니다.
)
echo.

REM Docker 확인
echo [2/4] Docker 확인 중...
docker info >nul 2>&1
if errorlevel 1 (
    echo     ✗ Docker Desktop이 실행되지 않았습니다.
    echo.
    echo     Docker Desktop을 실행하고 다시 시도하세요.
    pause
    exit /b 1
)
echo     ✓ Docker 실행 중
echo.

REM 기존 컨테이너 정리
echo [3/4] 이전 버전 정리 중...
docker-compose -f docker-compose.production.yml down >nul 2>&1
echo     ✓ 완료
echo.

REM 프로덕션 시작
echo [4/4] HMI 시스템 시작 중...
docker-compose -f docker-compose.production.yml up -d

if errorlevel 1 (
    echo.
    echo [오류] 시작 실패
    pause
    exit /b 1
)

echo.
echo ============================================================
echo    ✓ HMI 시스템 실행 중
echo ============================================================
echo.
echo [접속 정보]
echo    - HMI 화면: http://localhost
echo    - PLC 주소: %PLC_HOST%:%PLC_PORT%
echo.
echo [로그 확인]
echo    docker-compose -f docker-compose.production.yml logs -f
echo.
echo [종료]
echo    docker-compose -f docker-compose.production.yml down
echo.

REM 5초 후 브라우저 자동 실행
timeout /t 5 /nobreak >nul
start http://localhost

pause
```

---

## 원격 업데이트 시스템

### 1. SSH를 통한 원격 업데이트

```bash
#!/bin/bash
# update_hmi.sh (라즈베리파이/리눅스용)

echo "HMI 원격 업데이트 시작..."

# 백업
echo "[1/5] 현재 버전 백업..."
cp -r ~/HMI_REAL ~/HMI_REAL_backup_$(date +%Y%m%d_%H%M%S)

# 새 버전 다운로드
echo "[2/5] 새 버전 다운로드..."
cd ~
wget http://192.168.1.200/hmi/HMI_REAL_latest.tar.gz
tar -xzf HMI_REAL_latest.tar.gz

# 기존 컨테이너 중지
echo "[3/5] 기존 버전 중지..."
cd ~/HMI_REAL
docker-compose -f docker-compose.production.yml down

# 새 버전으로 교체
echo "[4/5] 새 버전 적용..."
cd ~
rm -rf ~/HMI_REAL
mv HMI_REAL_latest ~/HMI_REAL

# 새 버전 시작
echo "[5/5] 새 버전 시작..."
cd ~/HMI_REAL
docker-compose -f docker-compose.production.yml up -d

echo "✓ 업데이트 완료!"
```

### 2. 웹 기반 업데이트 시스템

백엔드에 업데이트 API 추가:

```python
# backend/main.py
from fastapi import UploadFile, File
import subprocess
import os

@app.post("/api/update")
async def update_system(file: UploadFile = File(...)):
    """시스템 업데이트 (관리자 전용)"""

    # 업로드된 파일 저장
    update_path = "/tmp/hmi_update.tar.gz"
    with open(update_path, "wb") as f:
        f.write(await file.read())

    # 백업 및 업데이트 스크립트 실행
    subprocess.run(["/usr/local/bin/update_hmi.sh"])

    return {"status": "success", "message": "업데이트 완료"}
```

---

## 모니터링 및 관리

### 1. 헬스 체크

```python
# backend/main.py
@app.get("/health")
async def health_check():
    """시스템 상태 확인"""
    return {
        "status": "healthy",
        "version": "1.0.0",
        "uptime": get_uptime(),
        "plc_connected": check_plc_connection()
    }
```

### 2. 로그 관리

```yaml
# docker-compose.production.yml
services:
  backend:
    logging:
      driver: "json-file"
      options:
        max-size: "10m"  # 파일당 최대 10MB
        max-file: "3"    # 최대 3개 파일 유지
```

### 3. 자동 재시작

```yaml
services:
  backend:
    restart: always  # 항상 재시작
    # restart: on-failure  # 오류 시만 재시작
    # restart: unless-stopped  # 수동 중지 제외하고 재시작
```

---

## 보안 설정

### 1. 방화벽 설정

```bash
# Linux (ufw)
sudo ufw allow 80/tcp   # HTTP
sudo ufw allow 502/tcp  # Modbus (필요시)
sudo ufw enable
```

### 2. HTTPS 설정 (선택)

```nginx
# nginx.conf (HTTPS)
server {
    listen 443 ssl;
    server_name hmi.example.com;

    ssl_certificate /etc/ssl/certs/hmi.crt;
    ssl_certificate_key /etc/ssl/private/hmi.key;

    # 나머지 설정...
}
```

---

## 문제 해결

### 컨테이너가 시작되지 않을 때

```bash
# 로그 확인
docker-compose -f docker-compose.production.yml logs

# 컨테이너 상태 확인
docker ps -a

# 강제 재빌드
docker-compose -f docker-compose.production.yml up --build -d
```

### PLC 연결 안 될 때

```bash
# PLC 연결 테스트
ping 192.168.1.100

# Modbus 포트 테스트
telnet 192.168.1.100 502
```

---

## 체크리스트

### 배포 전 체크리스트

```
☐ 프로덕션 Dockerfile 작성
☐ docker-compose.production.yml 작성
☐ .env.production 설정
☐ Nginx 설정 (프론트엔드)
☐ 로그 설정
☐ 자동 재시작 설정
☐ PLC IP 주소 확인
☐ 네트워크 설정 확인
☐ 방화벽 규칙 설정
```

### 현장 설치 체크리스트

```
☐ 하드웨어 확인 (패널 PC, 터치스크린)
☐ 네트워크 연결 확인
☐ Docker 설치
☐ HMI 프로그램 복사
☐ 환경 변수 설정
☐ 실행 테스트
☐ 자동 시작 설정
☐ PLC 통신 테스트
☐ 사용자 교육
```

---

**작성일:** 2025-01-18
**문서 버전:** 1.0
